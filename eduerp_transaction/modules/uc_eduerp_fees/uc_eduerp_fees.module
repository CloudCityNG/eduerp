<?php

/**
 * @author Kayode Odeyemi (dreyemi@gmail.com)
 *
 * @file
 * Ubercart integration of EduERP fees
 */

define('EDUERP_FEES_NORMAL', 'fees');
define('EDUERP_FEES_HOSTEL', 'hostel');
define('FEES_PAID', 'payment_received');
define('FEES_PENDING', 'pending');
define('HAS_SCHOLARSHIP', 1);
define('FEES_FULL', 'Full Amount');
define('FEES_FIRST_INSTALMENT', 'Instalment1');
define('FEES_SECOND_INSTALMENT', 'Instalment2');

/**
 * Pay fees menu callback
 *
 * @return
 *   - Drupal form
 */
function uc_eduerp_fees_pay_fees(&$form_state, $student_id) {
  global $user;
  $student_id = $user->uid;

  // forcefully clear the cart if it is not empty
  if($form_state['submitted'] == FALSE) {
    if(uc_cart_get_contents() != NULL) {
      uc_cart_empty($student_id);
    }
  }

  module_load_include('inc', 'student', 'student.rules');
  $form = array();

  if($fees_items = module_invoke('uc_eduerp_fees', 'eduerp_fees')) {
    $fees = $fees_items;
  }
  dsm($fees);

  // A student need to be cleared to progress
  if(!student_clearance_performed($student_id)) {
    $fees = array();
    drupal_set_message(t('Sorry, you need to be cleared to progress'), 'error');
    return FALSE;
  }

  // test if student is still a student (graduated or expelled)
  $session = variable_get('eduerp_current_session', '') ? variable_get('eduerp_current_session', '') : NULL;
  if(!student_next_level($student_id, $session)){
    $fees = NULL;
    drupal_set_message(t('Sorry. Your student record is no longer eligible to pay fees'), 'error');
    return FALSE;
  }

  if (uc_cart_get_contents() == NULL) { // if cart is empty
    $_SESSION['eduerp_fees_in_cart'] = FALSE;
  }

  // The paid fees items
  foreach($fees as $fee) {
    $paid_fees_items = uc_eduerp_fees_paid_items($student_id, $fee['item']['product_nid'], TRUE);
    // if $fees is paid for break everything
    if(in_array($fee['item']['product_nid'], $paid_fees_items) && $session) {
      $fees = array();
      drupal_set_message('You have already paid for this item. Consult the bursary', 'error');
      return FALSE;
    }
  }

  // If the student have these items in the cart already, redirect
  // to the /cart to prevent increment in cart quantity.
  // Also handles irregularities when the item added to cart is incomplete
  if($_SESSION['eduerp_fees_in_cart'] == TRUE | uc_cart_get_contents() != NULL) {
    drupal_set_message('Welcome back! Please continue from where you left off.');
    drupal_goto('cart');
  }


  $form['eduerp_fees'] = array(
    '#type' => 'fieldset',
    '#title' => t('Pay fees'),
    '#collapsible' => TRUE,
  );
  foreach($fees as $fee){
    $type = $fee['type'];
    $description = $fee['description'];
    $options = $fee['options'];
    $options_nid = (string)$options['nid'];

    // Invalidate fee if value of last_registration_date is the last date
    // Updates: late payment should still be allowed even after last_registration_date
    // So, these sort of fee items will not timeout. Reason, last_registration_date value
    // will be NULL or its date value will be in the past.

    // Israel statement: "Any transaction awaiting in the queue, for
    // current date > last_registration_date(not >=), without Late Registration Charge
    // included, must expire."

    // Payment must still be allowed even when last_registration_date is reached. The
    // difference is that from the 1st day following last_registration_date, Late
    // Registration Charge must apply.
    // status: Needs work ()
    /*if(uc_eduerp_fees_registration_is_late('fees')) {
      $fee = NULL;
      drupal_set_message(t('Student registration for this session is closed. Consult the registry'), 'error');
    }*/

    // Before item is added to cart, check for hostel reservation value
    // if hostel reservation has expired, set fees to NULL
    // if the fees record contains hostel key(hostel attribute id), check for expiration
    // status: Needs work
    /*if(array_key_exists('hostel', $fees) && $fees->hostel_reservation_expired) {
      $fees = NULL;
      drupal_set_message('Your hostel reservation has expired. Please consult the registry', 'error');
    }*/

    if($type == EDUERP_FEES_NORMAL) {
      foreach($fee['item'] as $key => $value){
        $nids[$key] = $value['product_nid'];
        $items[$key] = $value;
        $desc[$key] = $value['item_description'];

        $form['eduerp_fees']["$type_$key"] = array(
          '#type' => 'checkbox',
          '#title' => strip_tags($desc[$key]),
          '#default_value' => TRUE,
          '#disabled' => TRUE //($type == 'fees')
        );

      }
      // construct fees hidden fields separately
      foreach($nids as $nid) {
        $form['eduerp_fees'][$type . '_' . $nid] = array(
          '#type' => 'hidden',
          '#value' => $nid,
        );
      }
      foreach($items as $item) {
        // Identify extras
        // foreach of the fees item description, parse it to extract the extras
        $key_search = $item['item_description'];
        foreach(module_implements('eduerp_fees_alter') as $module) {
          // @todo - Make hook_eduerp_fees_alter argument to be options so that extras
          // can be altered with multiple items
          $item['extras']['fees_payment_format'] = module_invoke($module, 'eduerp_fees_alter', $key_search);
        }
        // @todo
        // Would be appropriate to use item_description here
        // but it is very unstructured and inconsistent
        $id = $item['product_nid'];
        $form['eduerp_fees']['product_item_' . $type . '_' . $id] = array(
          '#type' => 'hidden',
          '#value' => $item,
        );
        // get_fee_items reports 3 states of is_scholarship_applicable
        // @see staff_school_fees_create_modify_fee_item_form
        // NULL: Not set
        // 1: Yes - Scholarship is applicable
        // 2: No - Scholarship is not applicable
        $scholarship = $item['is_scholarship_applicable'];
        if(array_key_exists('is_scholarship_applicable', $item) && !is_null($scholarship)) { // We only care about when it is set
          // add a new item to $options
          if(!isset($options['has_scholarship'])) {
            //$options['has_scholarship'] = $scholarship;
            //$options[$item['product_nid']]['has_scholarship'] = $scholarship;
            $options['has_scholarship'] = $options['scholarship'];
          }
        }
      }
      $form['eduerp_fees']['options_' . $type. '_' . $options_nid] = array(
        '#type' => 'hidden',
        '#value' => $options,
      );
    }
    // Do the rest of the things for hostel
    if($type == EDUERP_FEES_HOSTEL) {
      $item = $fee['item'];
      $nid = $fee['item']['product_nid'];

      // Build a checkbox
      $form['eduerp_fees'][$type] = array(
        '#type' => 'checkbox',
        '#title' => strip_tags($description),
        '#default_value' => TRUE,
        '#disabled' => TRUE //($type == 'fees')
      );

      $form['eduerp_fees'][$nid] = array(
          '#type' => 'hidden',
          '#value' => $nid,
      );
      $form['eduerp_fees']["product_item_$type"] = array(
          '#type' => 'hidden',
          '#value' => $item,
      );
      $form['eduerp_fees']["options_$type_" . $options_nid] = array(
          '#type' => 'hidden',
          '#value' => $options,
      );
    }
  }
  $form['eduerp_fees']['uid'] = array(
    '#type' => 'hidden',
    '#value' => $student_id
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Pay Fees')
  );
  $form['#submit'][] = 'uc_eduerp_fees_pay_fees_form_submit';

  return $form;
}

/**
 *
 * @todo Write all modifications of uc_eduerp_fees_pay_fees to db
 *  for retrieval. uc_eduerp_fees_load_extras need this.
 */
function uc_eduerp_fees_pay_fees_form_submit($form, &$form_state) {
  $student_id = $form_state['values']['uid'];
  $values = array();
  foreach($form_state['values'] as $key => $value) {
    $vkeys[] = $key;
    $values[$key] = $value;
  }
  //dsm($vkeys);
  //dsm($values);
  $key_search = implode(',', array_values($vkeys));
  preg_match_all('/product_item_fees_\d+/', $key_search, $matches);
  // match options for fees option
  preg_match_all('/options_fees_\d+/', $key_search, $fees_option_matches);
  // find all hostel keys if it exists
  if(array_key_exists('hostel', $vkeys)) {
    preg_match_all('/product_item_hostel_\d+/', $key_search, $hostel_matches);
    preg_match_all('/options_hostel_\d+/', $key_search, $hostel_option_matches);
  }
  $matchs = array(
    'fees' => array_shift($matches),
    'fees_options' => array_shift($fees_option_matches),
    'hostel' => array_key_exists('hostel', $vkeys) ? array_shift($hostel_matches) : array(),
    'hostel_options' => array_key_exists('hostel', $vkeys) ? array_shift($hostel_option_matches) : array()
  );
  //$matchs['fees'] = array_shift($matches);
  /*$func = function($item, &$item_value) {
    $fees_items = array($item => $item_value);
    //$fees_items = array($item => 1);
    return $fees_items;
  };*/
  $product_fees = array();
  foreach($matchs['fees'] as $key => $value){
    $product_fees[$key] = $form_state['values'][$value];
    //$items = array_map($func, $match, $values);
  }
  foreach($matchs['fees_options'] as $key => $value) {
    $fees_options['options'] = $form_state['values'][$value];
  }
  foreach($matchs['hostel_options'] as $key => $value) {
    $hostel_options['options'] = $form_state['values'][$value];
  }
  $cart_items = array(
    'product_item_fees' => array(
      'item' => $product_fees,
      'options' => $fees_options['options']
    ),
    'hostel_item_fees' => array(
      'item' => $matchs['hostel'],
      'options' => array_key_exists('hostel', $vkeys)? $hostel_options['options'] : array()
    )
  );
  // remove all traces of hostel if it's not available
  if(!array_key_exists('hostel', $vkeys)) {
    unset($cart_items['hostel_item_fees']);
  }
  // subject = vkeys
  // for each of $vkeys that matches regex pattern
  // put all
  // $items = all of its values
  // @todo Move into a function and find alternative ways to get the
  // cart keys. Also get the quantity of each fee item to pass to uc_cart_add_item
  /*$cart_nids = array(
    $vkeys[2] => array(
      'item' => $form_state['values'][$vkeys[2]],
      'options' => $form_state['values'][$vkeys[3]]
    ),
    $vkeys[6] => array(
      'item' => $form_state['values'][$vkeys[6]],
      'options' => $form_state['values'][$vkeys[7]]
    ),
  );
  */
  //dsm($cart_items);
  $added = FALSE;
  foreach($cart_items as $product_item){
    $cart_item = $product_item;
    foreach($product_item['item'] as $key => $fees_values) {
      $product[$key] = $fees_values;
      $cartId = uc_cart_get_id();
      $nid = $product[$key]['product_nid'];
      if(array_key_exists('attribute_id', $product[$key])){
        $product_attribute = array('attributes' => array($product[$key]['attribute_id'] => $product[$key]['option_id']));
        //array_push($option, $product_attribute);
        $options = $cart_item['options'] + $product_attribute;
      }
    //dsm($options);
    // only if it's a product
    if(!empty($product)){
      uc_cart_add_item($product[$key]['product_nid'], 1, $options, $cartId, $msg = TRUE, $check_redirect = TRUE, $rebuild = TRUE);
      $added = TRUE;
      $fees = array(
        'title' => '',
        'type' => $options['type'],
        'description' => $product[$key]['item_description'],
        'nid' => $product[$key]['product_nid'],
        'uid' => $cartId,
        'extras' => serialize($product[$key]['extras']),
        'options' => serialize($options)
      );
      // Stays in here for 6 hours
      $form_state['storage'] = $fees;
      // drupal_write_record is serialized by default.
      // We don't need to care about the order
      if(db_result(db_query("SELECT nid from {fees} WHERE nid = %d", $product[$key]['product_nid']))) {
        drupal_write_record('fees', $fees, 'fee_id');
      }
      else {
        // do an insert
        drupal_write_record('fees', $fees);
        // watchdog drupal write record
        watchdog('fees', t('New fee record created by @uid', array('@uid' => $cartId)));
      }
    }else {
      drupal_set_message(t('Sorry, you are not eligible to pay fees. Please contact bursary'), 'error');
      watchdog('fees', t('Fees insertion into cart failed on @uid', array('@uid' => $cartId)));
    }
    }
  }
  if($added){
    $_SESSION['eduerp_fees_in_cart'] = TRUE;
    $form_state['redirect'] = 'cart';
  }
}

/**
 * Implementation of hook_eduerp_fees
 *
 * Fees with all necessary setup information included
 * Describes the fees structure.
 *
 * @return
 *   - $fees: The Fees object including it's type, setup
 *
 * @todo
 *   - Write a fees plugin to define custom fees type
 *   - Introduce a 'callback' key to store in db this fees structure for
 *  every module that implements it
 */
function uc_eduerp_fees_eduerp_fees($fees = array()) {
  global $user;

  $type = '';
  $uid = user_load($user->uid);

  static $fees_item;
  $fees_item = get_fee_items($uid->uid);
  if(!empty($fees_item)){
    // Fees
    $fees_item['item'] = $fees_item['fee_item_details'];
    foreach($fees_item['item'] as $key => $value) {
      $description[$key] = $value['item_description'];
      $fees_item['item'][$key]['extras'] = array();
    }
    // Add more user information since student has been cleared
    $profile = student_load_student_profile($uid->uid);
    //$options['jambno'] = $profile->profile_jambno;
    $fullnames = array($profile->profile_first_name, $profile->profile_last_name);
    //$options['fullnames'] = implode(' ', $fullnames);

    // Add institution
    module_load_include('inc', 'eduerp', 'eduerp.admin');
    $institution = eduerp_get_institution('name');
    //$options['institution'] = $institution->id;

    $fees_item['options'] = array(
      'type' => EDUERP_FEES_NORMAL,
      'nid' => $fees_item['studentFeeSetupNID'],
      'nationality' =>  $fees_item['nationality_name'],
      'programme' => $fees_item['fee_structure_name'], // Student course
      'level_name' => $fees_item['level_name'],
      'scholarship' => $fees_item['is_student_on_scholarship'], // True or False
      'allow_instalment' => $fees_item['instalment_payment_authorised'], // True or False
      'session' => $fees_item['session_name'],
      'late_registration' => $fees_item['late_reg_info'],
      'jambno' => $profile->profile_jambno,
      'fullnames' => implode(' ', $fullnames),
      'institution' => $institution->id
    );

    // hostel
    $fees_item['hostel'] = $fees_item['hostel_info'];
    $fees_item['options']['hostel'] = array(
      'nid' => $fees_item['hostel']['product_nid'],
      'type' => EDUERP_FEES_HOSTEL,
      'expiry_date' => $fees_item['hostel']['expiry_date'],
      'jambno' => $profile->profile_jambno,
      'fullnames' => implode(' ', $fullnames),
      'institution' => $institution->id
    );
  } else {
    $fees_item = array();
  }

  $fees['fees'] = array(
    'item' => $fees_item['item'],
    //'description' => $fees_item['item']['item_description'],
    'description' => $description,
    'options' => $fees_item['options'],
    'type' => EDUERP_FEES_NORMAL,
    'title' => t('Fees'), // Human-readable name
  );
  $fees['hostel'] = array(
    //'item' => $fees_item['hostel']['product_nid'],
    'item' => $fees_item['hostel'],
    'description' => $fees_item['hostel']['hostel_description'],
    'options' => $fees_item['options']['hostel'],
    'type' => EDUERP_FEES_HOSTEL,
    'title' => t('Hostel'),
    'extras' => array()
  );
  return $fees;
}

/**
 * Hook to define fees_structure
 *
 * @param $fees
 *   - The fees
 */
function uc_eduerp_fees_eduerp_fees_hook($fees) {
  foreach (module_implements('eduerp_fees') as $module) {
    $function = $module . '_eduerp_fees';
    $result = $function($fees);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Implements hook_eduerp_fees_eduerp_fees_alter
 *
 */
function uc_eduerp_fees_eduerp_fees_alter(&$items) {
  // array search the context value
  // when gotten, inject stuffs into $extras key
  if(!empty($items)) {
    preg_match_all('/Full Amount|Instalment1|Instalment2/', $items, $matches);
    foreach($matches as $key => $value) {
      return $value;
    }
  }
}

/**
 * All paid fees items gotten from EduPay
 *
 * Returns an array of all fees that are paid
 *
 * @params $items
 *  Paid items
 *
 * @return array
 */
function uc_eduerp_fees_paid_items($uid, $nid, $subscript = TRUE) {
  //$items include product_nid, attribute_id and status
  $items = array();
  $status_paid = FEES_PAID;
  $status_pending = FEES_PENDING;
  $result = db_query("SELECT * FROM {uc_order_products} WHERE nid = %d ORDER BY nid", $nid);
  $products = db_fetch_object($result);

  $result = db_query("SELECT order_id, data FROM {uc_orders} WHERE uid = %d and order_status = '%s' or '%s' and data IS NOT NULL", $uid, $status_paid, $status_pending);
  while($order = db_fetch_object($result)) {
    if($subscript) {
      $items[] = $products->nid;
      break;
    }
    $order->nid = $products->nid;
    $order->order_id = $order->order_id;
    $order->data = unserialize($order->data);
    $items[$order->nid] = $order;
  }
  //dsm(uc_order_module_invoke('load', $order, NULL));
  return $items;
}

/**
 * Gets the fees attributes including
 *   - product_nid
 *   - attribute_id
 *   - option_id
 *
 * @todo Needs rework
 */
function uc_eduerp_fees_fees_attributes($fees) {
  if(!empty($fees)) {
    foreach($fees as $fee) {
      $attribute_id = $fee['item']['attribute_id'];
      $attr_obj = uc_attribute_load($attribute_id);
      /*foreach($fee['item'] as $key => $fee_item) {
      }*/
    }
  }
  return $attribute_id;
}

/**
 * Load fees extras from the database. Accepts only
 * fees and hostel types as of writing
 *
 */
function uc_eduerp_fees_load_extras($uid, $type) {
  switch($type) {
    case 'fees':
      $result = db_query("SELECT * FROM {fees} WHERE uid = %d and type = '%s'", $uid, $type);
      while($fee_object = db_fetch_object($result)) {
        $extras[$fee_object->nid] = unserialize($fee_object->extras);
      }
      return $extras;
      break;
    case 'hostel':
      $result = db_query("SELECT * FROM {fees} WHERE uid = %d and type = '%s'", $uid, $type);
      while($fee_object = db_fetch_object($result)) {
        $extras[$fee_object->nid] = unserialize($fee_object->extras);
      }
      return $extras;
      break;
  }
}

/**
 * hook_update_invoke declaration
 */
function uc_eduerp_fees_update_invoke($op, $value, $schema = NULL, $field_value = NULL) {
  foreach(module_list() as $module) {
    $function = $module . '_update';
    if(function_exists($function)) {
      $function($op, $value, $schema, $field_value);
    }
  }
}

function uc_eduerp_fees_update_load($value, $schema, $field_value) {
  // $value should remain the same. Shouldn't be passed by reference
  $order_id = db_fetch_object(db_query("SELECT order_id FROM {$schema} WHERE tpin = '%s'", $value));
  return $order_id;
}

function uc_eduerp_fees_update_update($value, $schema, $field_value) {
  return db_query("UPDATE {$schema} set order_status = '$field_value' WHERE order_id = %d", $value);
}

function uc_eduerp_fees_update_delete($value, $schema, $field_value) {
  return db_query("DELETE FROM {$schema} WHERE order_id = %d", $value);
}

/**
 * Implementation of hook_update_{hook}
 *
 * @see
 *
 * @todo Convert this to rules and triggers
 */
function uc_eduerp_fees_update_fees($values) {
  //$order_id = uc_eduerp_fees_update_invoke('load', 'uc_orders', $values['tpin']);
  $order_id = $values['order_id'];
  $order = uc_order_load($order_id);
  $data = unserialize($order->data);
  // If status == payment_received
  // load the order_id by tpin (query eduerp_transaction table to get the tpin) sent from
  // edupay and update the ubercart order status to paid
  // run ubercart update query here to update an order
  if($values['status'] == FEES_PAID) { //Payment received
    uc_eduerp_fees_update_invoke('update', $order_id, 'uc_orders', FEES_PAID);
    if(isset($_SESSION['eduerp_fees_in_cart'])){
      unset($_SESSION['eduerp_fees_in_cart']);
    }
    watchdog('uc_eduerp_fees', t('Fees item in cart with order_id of @order_id has been successfully paid for by @uid', array('@order_id' => $order_id, '@uid' => $values['uid'])));
    return array('fees paid');
  }
  // If the fees paid for is of type hostel
  if($values['status'] == FEES_PAID && $values['type'] == EDUERP_FEES_HOSTEL) {
    // allocate bedspace for this user
    return hostel_allocation_allocate_bedspace($values['uid']);
  }
  if($values['service'] == INVOICE_REGENERATE) {
    // Load the order_id by edupay tpin (query eduerp_trasaction table to get the pin )
    // uc_eduerp_fees_update_invoke('load', $values['tpin'], 'eduerp_transaction');
    // set the order to unpaid. Parameters: uid and order id. Ubercart prefers canceled
    // db_query('UPDATE {uc_orders} set ')
    // get the status of the order
    // if it is not set to cancelled or is pending or in_checkout
    // set it to canceled
    $order_status = $order->order_status;
    //$possible_statuses = array('canceled', 'pending', 'in_checkout');
    if((uc_order_status_data($order_status, 'state') == 'pending' or 'in_checkout')) {
      $status = 'canceled';
      uc_eduerp_fees_update_invoke('update', $order_id, 'uc_orders', $status);
      watchdog('uc_eduerp_fees', t('Fees item in cart with order_id of @order_id of user @uid has been canceled', array('@order_id' => $order_id, '@uid' => $values['uid'])));
    }

    // @todo: Not sure about removing this item from cart yet
    if(uc_order_status_data($order_status, 'state') == 'canceled') {
      //remove the order item from cart and unset all other related SESSION variables
      //uc_eduerp_fees_update('delete', $order_id, 'uc_orders');
      // watchdog this
    }
    // load and rebuild the user's order invoice
    uc_eduerp_fees_invoice_regenerate($order_id);

    // if the product_attribute sent from edupay is hostel, revoke hostel allocation
    if($values['type'] == EDUERP_FEES_HOSTEL) {
      // @todo check if there's hostel reservation for the user beore
      // revoking the expiration
      hostel_allocation_revoke_expired_reservation($values['uid'], True);
      watchdog('uc_eduerp_fees', t('Fees item in cart with order_id of @order_id and a type of @type on user @uid', array('@order_id' => $order_id, '@type' => $values['type'], '@uid' => $values['uid'])));
    }

    // @todo send an email to user about all these actions
    // A link to the regenerated invoice to the user can download
    //
  }
}

function uc_eduerp_fees_invoice_regenerate($order_id) {
  return _uc_eduerp_fees_invoice_rebuild($order_id);
}

/**
 * load the invoice view (pdf_invoice)
 * views_get_view (get it from default)
 * reload the invoice at user's profile page
 * clear the cache
 *
 * Things to change on the invoice
 *  - print status as Unpaid
 */
function _uc_eduerp_fees_invoice_load($order_id) {
  $view = views_get_view_result('pdf_invoice', 'pdf_1', $order_id);
  $view[0]->uc_orders_order_status = 'canceled';
}

function _uc_eduerp_fees_invoice_rebuild($order_id) {
  return _uc_eduerp_fees_invoice_load($order_id);
}

/**
 * Get fees of type fees from the source
 *
 * All modifications within uc_eduerp_fees_pay_fees are
 * not available to the return items in this function
 */
function uc_eduerp_fees_get_fees($type = 'fees') {
  if($fees = module_invoke('uc_eduerp_fees', 'eduerp_fees')) {
    foreach($fees as $fee){
      if($fee['type'] == $type) {
        $items = $fee['item'];
      }
    }
     return $items;
  }
}

/**
 * Get fees items when an order is made
 *
 * @todo test the order object to make sure it is of type fees
 */
function uc_eduerp_fees_get_fees_order() {
  $order_id = intval($_SESSION['cart_order']);
  if($order_id > 0) {
    $order = uc_order_load($order_id);
  }
  return $order;
}

/**
 * Loads a subset of fees by type
 *
 * @param $type
 *   fees or hostel
 *
 * @return
 *   - array
 */
function uc_eduerp_fees_load_fee_options($type) {
  if(!is_null($type)){
    if($fees = module_invoke('uc_eduerp_fees', 'eduerp_fees')) {
      $typed = $fees[$type];
      return $typed['options'];
    }
  }
}

/**
 * Orders are regarded as items in UC.
 * Provides extra access to data in the order throughout
 * the life time of the ordering process.
 *
 * @param $type
 *  fees or hostel
 */
function uc_eduerp_fees_load_item_options($type){
}

/**
 * Determines whether late registration period is reached
 *
 * Since no info is given from get_fee_item about the timezone,
 * it defaults to Drupal's timezone
 *
 * @return Bool
 *
 */
function uc_eduerp_fees_registration_is_late() {
  $late = uc_eduerp_fees_load_fee_options(EDUERP_FEES_NORMAL);
  $late_value = $late['late_registration'];
  $late_date = $late_value['last_registration_date'];
  return (!is_null($late_date) && isset($late_value['amount'])) ? TRUE : FALSE;
}

/**
 * Implements hook_form_ID_alter
 *
 */
function uc_eduerp_fees_form_uc_eduerp_fees_pay_fees_alter(&$form, $form_state) {
  // Remove hostel if no reservation exists
  if(!is_reservation_existing($form['uid']['#value'])) {
    // unsets from screen, doesn't get removed from from array
    unset($form['eduerp_fees']['hostel']);
  }
}

/**
 * Implementation of hook_views_api().
 */
function uc_eduerp_fees_views_api() {
  return array(
    'api' => 2,
    //'path' => drupal_get_path('module', 'uc_eduerp_fees'),
    'path' => drupal_get_path('module', 'uc_eduerp_fees') . '/includes',
  );
}